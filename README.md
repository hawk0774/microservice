# Домашнее задание "Микросервисы: принципы"
# Решение задания  
## Задача 1: API-шлюз для микросервисной архитектуры

### Введение
В рамках построения микросервисной архитектуры в крупной компании требуется централизованный компонент для обработки входящих запросов — **API Gateway**.  
API-шлюз является единой точкой входа в систему и отвечает за маршрутизацию запросов, безопасность и базовые инфраструктурные функции.

Цель данной задачи — выбрать подходящее программное решение для реализации API Gateway, удовлетворяющее заданным требованиям.

---

## Требования к API Gateway
Выбранное решение должно обеспечивать:

- маршрутизацию запросов к соответствующим микросервисам на основе конфигурации;
- проверку аутентификационных данных (например, JWT / OAuth2);
- терминацию HTTPS (TLS termination).

---

## Сравнительная таблица решений

| Решение | Маршрутизация запросов | Проверка аутентификации | Терминация HTTPS | Интеграция с Kubernetes | Расширяемость | Применимость |
|--------|------------------------|--------------------------|------------------|--------------------------|---------------|--------------|
| **Envoy / Envoy Gateway** | Гибкая маршрутизация по host / path / headers / SNI | JWT (`jwt_authn`), внешняя авторизация (`ext_authz`), интеграция с OAuth2/OIDC | Да (terminate и passthrough) | Отличная поддержка через Gateway API | Фильтры, xDS, высокая гибкость | Крупные распределённые системы, высокая нагрузка |
| **Kong Gateway** | Маршруты и сервисы, декларативная конфигурация | JWT, OAuth2, API Keys, ACL (плагины) | Да | Kubernetes Ingress Controller | Плагины (Lua/Go), Enterprise-функции | Готовый API-management, быстрый старт |
| **Traefik** | Простая маршрутизация, автоматическое обнаружение сервисов | Middlewares, базовый JWT/OIDC | Да, встроенный Let's Encrypt | Очень хорошая, cloud-native | Middlewares и плагины | Небольшие и средние системы, простота эксплуатации |
| **NGINX / NGINX Plus** | Гибкая маршрутизация через конфигурацию | JWT, OAuth2 через модули и Lua | Да, высокая производительность | Ingress Controller | Lua и сторонние модули | Классические инфраструктуры, высокий контроль |

---

## Выбор решения

### Выбранное решение: **Envoy Gateway**

### Обоснование выбора
**Envoy Gateway** наиболее полно соответствует требованиям крупной микросервисной архитектуры по следующим причинам:

1. **Маршрутизация запросов**  
   Envoy поддерживает сложные правила маршрутизации на уровне L7 (HTTP), включая маршруты по домену, пути, заголовкам и SNI, что позволяет гибко управлять трафиком между микросервисами.

2. **Аутентификация и авторизация**  
   Встроенные механизмы проверки JWT и возможность подключения внешнего сервиса авторизации (`ext_authz`) позволяют реализовать централизованную и расширяемую модель безопасности.

3. **Терминация HTTPS**  
   Envoy поддерживает TLS-терминацию и passthrough-режимы, что позволяет безопасно обрабатывать входящий трафик и управлять сертификатами централизованно.

4. **Масштабируемость и развитие**  
   Envoy Gateway хорошо интегрируется с Kubernetes и стандартом Gateway API, а также является базовым компонентом для service mesh решений, что обеспечивает архитектурный задел на будущее.

---

## Итог
Для крупной компании с микросервисной архитектурой оптимальным выбором API-шлюза является **Envoy Gateway**, так как он сочетает в себе высокую производительность, гибкую маршрутизацию, расширенные механизмы безопасности и готовность к масштабированию и дальнейшему развитию инфраструктуры.

# Задача 2: Брокер сообщений

## Требования
Брокер сообщений должен обеспечивать:

- кластеризацию для высокой надёжности;
- хранение сообщений на диске в процессе доставки;
- высокую скорость обработки сообщений;
- поддержку различных форматов сообщений;
- разделение прав доступа к потокам сообщений;
- простоту эксплуатации.

---

## Сравнительная таблица брокеров сообщений

| Брокер сообщений | Кластеризация | Хранение на диске | Производительность | Форматы сообщений | Контроль доступа | Простота эксплуатации |
|------------------|---------------|-------------------|--------------------|-------------------|------------------|------------------------|
| **Apache Kafka** | Да (partition + replication) | Да | Очень высокая | Любые (JSON, Avro, Protobuf, Binary) | ACL, SASL, RBAC | Средняя (требует опыта) |
| **RabbitMQ** | Да (cluster + quorum queues) | Да | Средняя | JSON, XML, Binary | RBAC, vhost | Высокая |
| **Apache Pulsar** | Да (segment storage) | Да | Очень высокая | Любые | RBAC, namespaces | Средняя |
| **NATS JetStream** | Да | Да | Высокая | Любые | Accounts, permissions | Высокая |
| **ActiveMQ Artemis** | Да | Да | Средняя | JMS, JSON, XML | RBAC | Средняя |

---

## Выбор решения

### Выбранное решение: **Apache Kafka**

### Обоснование выбора
Apache Kafka является оптимальным решением для крупной распределённой системы по следующим причинам:

1. **Надёжность и отказоустойчивость**  
   Kafka использует репликацию партиций между брокерами, что обеспечивает устойчивость к отказам узлов.

2. **Хранение сообщений на диске**  
   Сообщения сохраняются на диске и могут быть переиспользованы потребителями, что позволяет реализовать event-driven архитектуру.

3. **Высокая производительность**  
   Kafka оптимизирована для обработки больших объёмов данных с минимальной задержкой и высокой пропускной способностью.

4. **Гибкость форматов сообщений**  
   Kafka не накладывает ограничений на формат сообщений и поддерживает работу с JSON, Avro, Protobuf и бинарными данными.

5. **Безопасность и изоляция**  
   Поддержка ACL, SASL и TLS позволяет гибко разграничивать доступ к топикам.

6. **Соответствие масштабу крупной компании**  
   Несмотря на более сложную эксплуатацию по сравнению с RabbitMQ, Kafka лучше подходит для систем с большим количеством сервисов и высоким трафиком.

---

## Итоговое решение
Для построения надёжной и масштабируемой микросервисной инфраструктуры рекомендуется использовать **Apache Kafka** в качестве брокера сообщений для асинхронного взаимодействия сервисов.

